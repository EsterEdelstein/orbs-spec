syntax = "proto3";

import "protocol/primitives.proto";
import "protocol/protocol-primitives.proto";
import "protocol/transaction.proto";

message BlockPair { 
  TransactionsBlock transactions_block = 1;
  ResultsBlock results_block = 2;
}

message TransactionsBlock {
  TransactionsBlockHeader header = 1;
  TransactionsBlockMetaData meta_data = 2; 
  TransactionsBlockBody body = 3;
  TransactionsBlockProof block_proof = 4;
}

message ResultsBlock {
  ResultsBlockHeader header = 1;
  ResultsBlockBody body = 2;
  ResultsBlockProof block_proof = 3;
}

message TransactionsBlockHeader {
  Uint32 version = 1;
  Uint32 virtual_chain = 2;
  Uint64 block_height = 3;
  SHA256 prev_block_hash_ptr = 4;
  Uint64 time_stamp = 5;
  SHA256 transactions_root_hash = 6;
  SHA256 meta_data_hash = 7;
}

message TransactionsBlockMetaData {
  Uint32 version = 1;
  repeated Uint32 nodes_reputaion = 2;
}

message TransactionsBlockBody {
  repeated SignedTransaction transaction = 1;
}

message TransactionsBlockProof {
  Bytes block_proof = 1;
  //Bytes consensus_dependent_data = 1; // part of the signature, opaque to the protocol.
  //repeated BlockProof block_signature = 2;
  //SHA256 transactions_header_hash = 3; - TBD clarifies the validation.
}

message ResultsBlockHeader {
  Uint32 version = 1;
  Uint32 virtual_chain = 2;
  Uint64 block_height = 3;
  SHA256 prev_block_hash_ptr = 4;
  Uint64 time_stamp = 5;
  SHA256 receipts_root_hash = 6;
  SHA256 state_diff_hash = 7;
  SHA256 transactions_block_hash_ptr = 8;
  SHA256 pre_execution_state_root_hash = 9;
  ResultsBlockBloomFilter bloom_filter = 10;
}

// Transaction id bloom filter format:
// Set H(1, `tx_id`) for each transaction `tx_id` (concat byte with value 0x01 with `tx_id` and insert).

// Transaction timestamp bloom filter format:
// TODO


message ResultsBlockBloomFilter {
  Bytes filter = 1;
  // Events bloom filter: (Hard coded indices: 1 - tx_id, 2 - Sender address, 3 - Smart contract address)
}

message ResultsBlockBody {
  repeated TransactionReceipt transaction_receipt = 1;
  repeated ContractStateDiff contract_state_diff = 2;
}

message ResultsBlockProof {
  Bytes block_proof = 1;
//  Bytes consensus_dependent_data = 1; // part of the signature, opaque to the protocol.
//  repeated BlockProof block_signature = 2;
}